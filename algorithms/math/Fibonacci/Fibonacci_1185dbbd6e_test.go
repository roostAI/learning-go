/*
Test generated by RoostGPT for test go-sample using AI Type Azure Open AI and AI Model roost-gpt4-32k

1. Scenario: Test with a positive number
   - Given a positive number n
   - When the fibonacci function is called with n
   - Then the sequence of Fibonacci number at position n should be returned.

2. Scenario: Test with zero as input
   - Given zero as input
   - When the fibonacci function is called with zero
   - Then the result should be zero, as the fibonacci of zero is zero.

3. Scenario: Test with one as input
   - Given one as input
   - When the fibonacci function is called with one
   - Then the result should be one, as the fibonacci of one is one.

4. Scenario: Test with two as input
   - Given two as input
   - When the fibonacci function is called with two
   - Then the result should be one, as the fibonacci of two is one.

5. Scenario: Test with larger number as input
   - Given a larger number as input
   - When the fibonacci function is called with the larger number
   - Then the correct fibonacci number at that position should be returned.

6. Scenario: Test with negative number
   - Given a negative number as input
   - When the fibonacci function is called with a negative number
   - Since fibonacci isn't valid for negative numbers, the behavior is undefined and should ideally be handled in test code.

7. Scenario: Test with extremely large positive number
   - Given an extremely large positive number as input
   - When the fibonacci function is called with this number
   - Assess how the function handles possible overflow conditions, it may not return the correct fibonacci number due to integer overflow.

8. Scenario: Performance Test
   - Given a moderately large positive number n
   - When the fibonacci function is called with n
   - Then the function should return the answer in a reasonable amount of time and not cause any performance issues.
*/
package Fibonacci

import (
	"fmt"
	"testing"
)

func TestFibonacci_1185dbbd6e(t *testing.T) {

	tests := []struct {
		name string
		n    int
		want int
	}{
		{
			name: "Test with a positive number",
			n:    5,
			want: 5,
		},
		{
			name: "Test with zero as input",
			n:    0,
			want: 0,
		},
		{
			name: "Test with one as input",
			n:    1,
			want: 1,
		},
		{
			name: "Test with two as input",
			n:    2,
			want: 1,
		},
		{
			name: "Test with larger number as input",
			n:    20,
			want: 6765,
		},
		{
			name: "Test with negative number",
			n:    -7,
			want: 0, // In this case, fibonacci function doesn't handle negative numbers, therefore expecting 0
		},
		{
			name: "Test with extremely large positive number",
			n:    92, // The 93rd fibonacci number is larger than max int, hence 92
			want: 7540113804746346429,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			got := fibonacci(tc.n)
			if got != tc.want {
				t.Fatalf("Fibonacci() = %v; want %v", got, tc.want)
			}
		})
	}

	// Performance Test
	{
		t.Helper()
		t.StartTimer()
		_ = fibonacci(20)
		t.StopTimer()
		fmt.Printf("Performance Test: Time taken for fibonacci(20) <= %v\n", t.Result().Duration)
	}
}
