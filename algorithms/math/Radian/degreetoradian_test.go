// ********RoostGPT********
/*
Test generated by RoostGPT for test unit-golang using AI Type  and AI Model 

ROOST_METHOD_HASH=degreeToRadian_19ddfa9792
ROOST_METHOD_SIG_HASH=degreeToRadian_c38219c312

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/algorithms/math/Radian/radian_test.go
Test Cases:
    [TestDegreeToRadian]

================================VULNERABILITIES================================
Vulnerability: CWE-681: Incorrect Conversion between Numeric Types
Issue: The function uses float64 for degree input and calculation, which may lead to precision loss or unexpected results for certain inputs due to floating-point arithmetic limitations.
Solution: Consider using a more precise numeric type like big.Float for critical angle calculations, or implement error handling for edge cases.

Vulnerability: Input Validation
Issue: The function lacks input validation, potentially allowing invalid degree values (e.g., NaN, Inf) to be processed, leading to unexpected behavior or errors.
Solution: Implement input validation to check for valid degree ranges and special values before performing the conversion.

================================================================================
Based on the given function and the existing test case, here are additional test scenarios for the `degreeToRadian` function:

Scenario 1: Test Zero Degree Conversion

Details:
  Description: Verify that zero degrees are correctly converted to zero radians.
Execution:
  Arrange: No special arrangement needed.
  Act: Call degreeToRadian(0).
  Assert: Check if the result is equal to 0.
Validation:
  This test ensures that the function handles the base case correctly. Zero degrees should always correspond to zero radians, which is an important mathematical property.

Scenario 2: Test Negative Degree Conversion

Details:
  Description: Ensure that negative degree values are correctly converted to their radian equivalents.
Execution:
  Arrange: Prepare a negative degree value, e.g., -30.
  Act: Call degreeToRadian(-30).
  Assert: Verify that the result is equal to -π/6 (approximately -0.5235987755982989).
Validation:
  This test checks if the function correctly handles negative inputs, which is crucial for applications dealing with rotations or angles in both directions.

Scenario 3: Test Large Degree Value

Details:
  Description: Verify the function's behavior with a large degree value.
Execution:
  Arrange: Choose a large degree value, e.g., 3600 (10 full rotations).
  Act: Call degreeToRadian(3600).
  Assert: Check if the result is equal to 20π (approximately 62.83185307179586).
Validation:
  This test ensures that the function can handle large inputs without loss of precision or overflow issues, which is important for applications dealing with multiple rotations.

Scenario 4: Test Precision for Small Angle

Details:
  Description: Check the precision of the conversion for a very small angle.
Execution:
  Arrange: Choose a very small degree value, e.g., 0.0001.
  Act: Call degreeToRadian(0.0001).
  Assert: Verify that the result is very close to 1.7453292519943295e-6 (use math.Abs(result - expected) < epsilon for comparison).
Validation:
  This test is crucial for ensuring the function maintains high precision for very small angles, which can be important in scientific or engineering applications.

Scenario 5: Test 360 Degree Conversion

Details:
  Description: Verify that 360 degrees are correctly converted to 2π radians.
Execution:
  Arrange: No special arrangement needed.
  Act: Call degreeToRadian(360).
  Assert: Check if the result is equal to 2π (approximately 6.283185307179586).
Validation:
  This test ensures that a full rotation is correctly represented in radians, which is a fundamental property of the degree-to-radian conversion.

These scenarios cover additional aspects of the function's behavior, including edge cases and precision considerations, complementing the existing test case provided.
*/

// ********RoostGPT********
package Radian

import (
	"math"
	"testing"
)

func TestDegreeToRadianConversion(t *testing.T) {
	tests := []struct {
		name     string
		degree   float64
		expected float64
		epsilon  float64
	}{
		{
			name:     "Zero Degree Conversion",
			degree:   0,
			expected: 0,
			epsilon:  1e-9,
		},
		{
			name:     "Negative Degree Conversion",
			degree:   -30,
			expected: -math.Pi / 6,
			epsilon:  1e-9,
		},
		{
			name:     "Large Degree Value",
			degree:   3600,
			expected: 20 * math.Pi,
			epsilon:  1e-9,
		},
		{
			name:     "Precision for Small Angle",
			degree:   0.0001,
			expected: 1.7453292519943295e-6,
			epsilon:  1e-15,
		},
		{
			name:     "360 Degree Conversion",
			degree:   360,
			expected: 2 * math.Pi,
			epsilon:  1e-9,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := degreeToRadian(tt.degree)
			if math.Abs(result-tt.expected) > tt.epsilon {
				t.Errorf("degreeToRadian(%f) = %f, want %f (difference: %e)", tt.degree, result, tt.expected, math.Abs(result-tt.expected))
			}
		})
	}
}
