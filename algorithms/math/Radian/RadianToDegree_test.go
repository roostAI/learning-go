// ********RoostGPT********
/*
Test generated by RoostGPT for test unit-golang using AI Type  and AI Model 

ROOST_METHOD_HASH=radianToDegree_5778708a96
ROOST_METHOD_SIG_HASH=radianToDegree_9d9fa92dd5

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/algorithms/math/Radian/radian_test.go
Test Cases:
    [TestRadianToDegree]

================================VULNERABILITIES================================
Vulnerability: CWE-682: Incorrect Calculation
Issue: The function uses floating-point arithmetic for degree conversion, which may lead to precision errors in certain cases.
Solution: Consider using a more precise constant for Pi, such as math.Pi, or implement a more robust conversion algorithm if high precision is required.

Vulnerability: Input Validation
Issue: The function does not validate the input, potentially allowing invalid or extreme values that could lead to unexpected results or errors.
Solution: Implement input validation to check for NaN, Inf, or out-of-range values before performing the conversion.

================================================================================
Based on the provided function and existing test, here are additional test scenarios for the `radianToDegree` function:

Scenario 1: Test Zero Radian Input

Details:
  Description: Check if the function correctly converts 0 radians to 0 degrees.
Execution:
  Arrange: Prepare a zero radian input.
  Act: Call radianToDegree(0).
  Assert: Verify that the result is 0 degrees.
Validation:
  This test ensures the function handles the base case of zero correctly, which is important for mathematical accuracy.

Scenario 2: Test Negative Radian Input

Details:
  Description: Verify that the function correctly handles negative radian values.
Execution:
  Arrange: Prepare a negative radian value, e.g., -π/6.
  Act: Call radianToDegree(-math.Pi / 6).
  Assert: Check if the result is -30 degrees (with a small tolerance for floating-point precision).
Validation:
  This test ensures the function correctly handles negative angles, which is crucial for applications involving rotations or directions.

Scenario 3: Test Large Positive Radian Input

Details:
  Description: Test the function's behavior with a large positive radian value.
Execution:
  Arrange: Prepare a large radian value, e.g., 10π.
  Act: Call radianToDegree(10 * math.Pi).
  Assert: Verify that the result is 1800 degrees (with a small tolerance for floating-point precision).
Validation:
  This test checks if the function can handle larger angles correctly, which is important for applications that may deal with multiple rotations.

Scenario 4: Test Very Small Positive Radian Input

Details:
  Description: Verify the function's accuracy with a very small positive radian value.
Execution:
  Arrange: Prepare a very small radian value, e.g., 1e-6.
  Act: Call radianToDegree(1e-6).
  Assert: Check if the result is approximately 5.72957795130823e-5 degrees (with appropriate tolerance).
Validation:
  This test ensures the function maintains accuracy for very small angles, which can be critical in high-precision applications.

Scenario 5: Test Radian Value Slightly Above 2π

Details:
  Description: Test the function's behavior with a radian value slightly above 2π.
Execution:
  Arrange: Prepare a radian value just above 2π, e.g., 2π + 0.1.
  Act: Call radianToDegree(2*math.Pi + 0.1).
  Assert: Verify that the result is slightly above 360 degrees (with appropriate tolerance).
Validation:
  This test checks if the function correctly handles angles that wrap around a full circle, which is important for consistency in circular measurements.

These scenarios cover a range of inputs including zero, negative values, large values, very small values, and values near full rotations, providing a comprehensive test suite for the `radianToDegree` function.
*/

// ********RoostGPT********
package Radian

import (
	"math"
	"testing"
)

func TestRadianToDegree(t *testing.T) {
	tests := []struct {
		name      string
		input     float64
		expected  float64
		tolerance float64
	}{
		{
			name:      "Zero Radian Input",
			input:     0,
			expected:  0,
			tolerance: 1e-9,
		},
		{
			name:      "Negative Radian Input",
			input:     -math.Pi / 6,
			expected:  -30,
			tolerance: 1e-9,
		},
		{
			name:      "Large Positive Radian Input",
			input:     10 * math.Pi,
			expected:  1800,
			tolerance: 1e-9,
		},
		{
			name:      "Very Small Positive Radian Input",
			input:     1e-6,
			expected:  5.72957795130823e-5,
			tolerance: 1e-9,
		},
		{
			name:      "Radian Value Slightly Above 2π",
			input:     2*math.Pi + 0.1,
			expected:  360 + 5.72957795130823,
			tolerance: 1e-9,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := radianToDegree(tt.input)
			if math.Abs(result-tt.expected) > tt.tolerance {
				t.Errorf("radianToDegree(%f) = %f; want %f (tolerance: %f)", tt.input, result, tt.expected, tt.tolerance)
			}
		})
	}
}
