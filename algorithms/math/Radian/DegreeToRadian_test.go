// ********RoostGPT********
/*
Test generated by RoostGPT for test unit-golang using AI Type  and AI Model 

ROOST_METHOD_HASH=degreeToRadian_19ddfa9792
ROOST_METHOD_SIG_HASH=degreeToRadian_c38219c312

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/algorithms/math/Radian/radian_test.go
Test Cases:
    [TestDegreeToRadian]

================================VULNERABILITIES================================
Vulnerability: CWE-189: Numeric Errors
Issue: Potential loss of precision when converting from float64 to radians. Large degree values may lead to inaccurate results.
Solution: Consider using a more precise conversion method or limiting input range. Implement input validation to handle extreme values.

Vulnerability: Input Validation
Issue: No input validation for the degree parameter. Negative or extremely large values could lead to unexpected behavior.
Solution: Add input validation to ensure degree values are within a reasonable range before performing the conversion.

================================================================================
Based on the provided function and existing test case, here are additional test scenarios for the `degreeToRadian` function:

Scenario 1: Test Zero Degree Conversion

Details:
  Description: Verify that zero degrees are correctly converted to zero radians.
Execution:
  Arrange: No special arrangement needed.
  Act: Call degreeToRadian(0)
  Assert: Check if the result is equal to 0.
Validation:
  This test ensures that the function handles the base case of 0 degrees correctly. It's important because 0 is a common input and should produce a precise result.

Scenario 2: Test Negative Degree Conversion

Details:
  Description: Ensure that negative degree values are correctly converted to their radian equivalents.
Execution:
  Arrange: Prepare a negative degree value, e.g., -90.
  Act: Call degreeToRadian(-90)
  Assert: Verify that the result is equal to -math.Pi / 2.
Validation:
  This test checks if the function correctly handles negative inputs, which is crucial for applications dealing with rotations or directions in both positive and negative ranges.

Scenario 3: Test Large Positive Degree Conversion

Details:
  Description: Verify the accuracy of conversion for large positive degree values.
Execution:
  Arrange: Choose a large degree value, e.g., 3600 (10 full rotations).
  Act: Call degreeToRadian(3600)
  Assert: Check if the result is equal to 20 * math.Pi (10 full rotations in radians).
Validation:
  This test ensures that the function maintains accuracy for large inputs, which is important for applications that might deal with multiple rotations or large angle values.

Scenario 4: Test Precision for Small Degree Values

Details:
  Description: Check the precision of conversion for small degree values.
Execution:
  Arrange: Select a small degree value, e.g., 0.1.
  Act: Call degreeToRadian(0.1)
  Assert: Verify that the result is close to the expected value (0.1 * math.Pi / 180) within a small tolerance.
Validation:
  This test is crucial for ensuring the function maintains precision for small angle conversions, which can be important in high-precision applications or calculations.

Scenario 5: Test Degree Value at 360

Details:
  Description: Verify that 360 degrees correctly converts to 2Ï€ radians.
Execution:
  Arrange: No special arrangement needed.
  Act: Call degreeToRadian(360)
  Assert: Check if the result is equal to 2 * math.Pi.
Validation:
  This test is important to ensure that a full rotation is correctly represented in radians, which is a common use case in circular or periodic calculations.

These scenarios cover various aspects of the function's behavior, including edge cases (zero, negative values), precision checks, and full rotation scenarios. They complement the existing test case by exploring additional important scenarios not covered in the original test.
*/

// ********RoostGPT********
package Radian

import (
	"math"
	"testing"
)

func TestDegreeToRadianConversion(t *testing.T) {
	tests := []struct {
		name      string
		degree    float64
		expected  float64
		tolerance float64
	}{
		{
			name:      "Zero Degree Conversion",
			degree:    0,
			expected:  0,
			tolerance: 1e-9,
		},
		{
			name:      "Negative Degree Conversion",
			degree:    -90,
			expected:  -math.Pi / 2,
			tolerance: 1e-9,
		},
		{
			name:      "Large Positive Degree Conversion",
			degree:    3600,
			expected:  20 * math.Pi,
			tolerance: 1e-9,
		},
		{
			name:      "Small Degree Value Precision",
			degree:    0.1,
			expected:  0.1 * math.Pi / 180,
			tolerance: 1e-9,
		},
		{
			name:      "Full Rotation (360 Degrees)",
			degree:    360,
			expected:  2 * math.Pi,
			tolerance: 1e-9,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := degreeToRadian(tt.degree)
			if math.Abs(result-tt.expected) > tt.tolerance {
				t.Errorf("degreeToRadian(%f) = %f; want %f (within tolerance %f)",
					tt.degree, result, tt.expected, tt.tolerance)
			}
		})
	}
}
