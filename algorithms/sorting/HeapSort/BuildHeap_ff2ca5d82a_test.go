/*
Test generated by RoostGPT for test go-sample using AI Type Azure Open AI and AI Model roost-gpt4-32k

1. Test scenario: Check whether an empty array returns an empty heap.
2. Test scenario: Check whether a single-element array is being correctly transformed into a valid heap.
3. Test scenario: Check whether a sorted array (ascending/descending) is being correctly transformed into a valid heap.
4. Test scenario: Check whether a array with multiple occurrences of the same element is correctly transformed into a valid heap.
5. Test scenario: Check whether a random order array is being correctly transformed into a valid heap.
6. Test scenario: Check that the function BuildHeap maintains the heap property i.e., each parent node is either greater than or equal to (in case of max heap), or less than or equal to (in case of min heap), its child nodes.
7. Test scenario: Check how the BuildHeap function handles a large size array (to check performance scalability).
8. Test scenario: Check whether all elements of the original array exist in the heap.
9. Test scenario: Check what happens when the input array contains negative integers. The function should still work correctly and transform the array into a valid heap.
10. Test scenario: Check that BuildHeap executes successfully without any panic or errors for diverse array inputs.
*/
package HeapSort

import (
	"reflect"
	"testing"
)

func TestBuildHeap_ff2ca5d82a(t *testing.T) {
	t.Parallel()
	type output struct {
		Heap  Heap
		array []int
		err   error
	}

	testCases := []struct {
		name   string
		array  []int
		output output
	}{
		{
			name:  "EmptyArray",
			array: []int{},
			output: output{
				Heap:  Heap{},
				array: []int{},
				err:   nil,
			},
		},
		{
			name:  "SingleElementArray",
			array: []int{1},
			output: output{
				Heap:  Heap{},
				array: []int{1},
				err:   nil,
			},
		},
		{
			name:  "SortedArray",
			array: []int{1, 2, 3, 4, 5},
			output: output{
				Heap:  Heap{},
				array: []int{5, 4, 3, 2, 1},
				err:   nil,
			},
		},
		// TODO: Add more test cases to cover all other scenarios.
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			heap := &Heap{}

			heap.BuildHeap(tc.array)
			validateHeapProperty(t, tc.array)

			if got, want := tc.array, tc.output.array; !reflect.DeepEqual(got, want) {
				t.Fatalf("Heap.BuildHeap() = %v, want %v", got, want)
			}

			for _, value := range tc.output.array {
				_, found := find(tc.array, value)
				if !found {
					t.Fatalf("Heap.BuildHeap() failed to keep original element: %d", value)
				}
			}
			t.Logf("Success => Scenario: %v", tc.name)
		})
	}
}

func validateHeapProperty(t *testing.T, array []int) {
	for i := len(array)/2 - 1; i >= 0; i-- {
		left := 2*i + 1
		right := 2*i + 2
		largest := i

		if left < len(array) && array[left] > array[largest] {
			largest = left
		}
		if right < len(array) && array[right] > array[largest] {
			largest = right
		}

		if largest != i {
			t.Errorf("The heap property failed at index %d for value %d", i, array[i])
		}
	}
}

func find(array []int, target int) (int, bool) {
	for i, value := range array {
		if value == target {
			return i, true
		}
	}

	return -1, false
}
