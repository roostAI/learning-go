/*
Test generated by RoostGPT for test go-sample using AI Type Azure Open AI and AI Model roost-gpt4-32k

1. Positive Case: Test the Heapify function with a properly-initialized integer array. Verify that the heap array is sorted correctly.

2. Negative Case: Test the Heapify function with a null array. The function should not throw any exceptions or errors.

3. Positive Case: Test the Heapify function with a single element array. Verify that the function handles this properly, as this is an edge case.

4. Negative Case: Test the Heapify function with an array that already in max heap order. The function should return the array in the same order.

5. Positive Case: Test the Heapify function with duplicate elements in the array. Verify that Heapify sorts these elements correctly.

6. Negative Case: Test the Heapify function with a root index that is greater than or equal to the length of the array. The function should handle this invalid argument appropriately.

7. Positive Case: Test the Heapify function with negative numbers in the array. The function should be able to handle negatives and sort them correctly.

8. Negative Case: Test Heapify function with non-integer values. It should give a relevant error message or handle the non-integer values appropriately.

9. Positive Case: Test Heapify function with a large array to determine the performance and efficiency of the algorithm.

10. Negative Case: Test the Heapify function's recursion logic by providing an array where the root is smaller than its right and left child nodes. Verify it correctly and recursively swaps elements.
*/
package HeapSort

import (
	"reflect"
	"testing"
)

func TestHeapify_468e16fe5b(t *testing.T) {
	tests := []struct {
		name    string
		array   []int
		root    int
		length  int
		want    []int
		wantErr bool
	}{
		{
			name:    "PositiveCase1",
			array:   []int{4, 10, 3, 5, 1},
			root:    0,
			length:  5,
			want:    []int{10, 5, 3, 4, 1},
			wantErr: false,
		},
		{
			name:    "NegativeCase1",
			array:   []int{},
			root:    0,
			length:  0,
			want:    []int{},
			wantErr: false,
		},
		{
			name:    "PositiveCase2",
			array:   []int{1},
			root:    0,
			length:  1,
			want:    []int{1},
			wantErr: false,
		},
		{
			name:    "NegativeCase2",
			array:   []int{9, 8, 5, 6, 3, 2, 3, 1},
			root:    0,
			length:  8,
			want:    []int{9, 8, 5, 6, 3, 2, 3, 1},
			wantErr: false,
		},
		{
			name:    "PositiveCase3",
			array:   []int{5, 3, 2, 5},
			root:    0,
			length:  4,
			want:    []int{5, 5, 2, 3},
			wantErr: false,
		},
		{
			name:    "NegativeCase3",
			array:   []int{5, 3, 2, 1},
			root:    5,
			length:  4,
			want:    []int{5, 3, 2, 1},
			wantErr: true,
		},
		{
			name:    "PositiveCase4",
			array:   []int{-5, -3, -2, -1},
			root:    0,
			length:  4,
			want:    []int{5, 5, 2, 3},
			wantErr: false,
		},
		{
			name:    "NegativeCase4",
			array:   []int{5, 3, 2},
			root:    0,
			length:  4,
			want:    []int{5, 3, 2},
			wantErr: true,
		},
		{
			name:    "PositiveCase5",
			array:   []int{10000, 5, 10000, 3, 2, 1},
			root:    0,
			length:  6,
			want:    []int{10000, 5, 10000, 3, 2, 1},
			wantErr: false,
		},
		{
			name:    "NegativeCase5",
			array:   []int{5, 3, 7, 2, 1},
			root:    0,
			length:  5,
			want:    []int{7, 5, 3, 2, 1},
			wantErr: false,
		},
	}

	heap := Heap{}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			arrayCopy := make([]int, len(tt.array))
			copy(arrayCopy, tt.array)
			func() {
				defer func() {
					if r := recover(); r != nil {
						t.Errorf("Heapify() paniced - %v", r)
						return
					}
				}()

				heap.Heapify(arrayCopy, tt.root, tt.length)

				if !reflect.DeepEqual(arrayCopy, tt.want) {
					t.Errorf("Heapify() = %v, want %v", arrayCopy, tt.want)
				}
			}()
		})
	}
}
