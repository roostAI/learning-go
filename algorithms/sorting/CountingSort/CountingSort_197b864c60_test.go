/*
Test generated by RoostGPT for test go-sample using AI Type Azure Open AI and AI Model roost-gpt4-32k

Test Scenario 1:
  Test the function with array of integers in ascending order. Verify that the sorted array returned by the function is as expected.

Test Scenario 2:
  Test the function with array of integers in descending order. Verify the sorting functionality by comparing the function output with the expected array.

Test Scenario 3:
  Test the function with an array containing both positive and negative integers. The function should handle negative values correctly.

Test Scenario 4:
  Test the function with an array containing same integer values. The function should maintain stability in sorting and should return an array with the same value.

Test Scenario 5:
  Test the function with a large array of random integers. Validate the performance and the speed of the function.

Test Scenario 6:
  Test the function with an array of integers contains very large and very small integers. Verify that the function can handle extreme cases.

Test Scenario 7:
  Test the function with an array containing only one value.

Test Scenario 8:
  Test the output of the function for an empty array. The function should return an empty array when the input array is empty.

Test Scenario 9:
  Test the function with input that is null or undefined. It should handle these gracefully, perhaps by throwing an exception.

Test Scenario 10:
  Test the function with non-integer inputs. Validate that the function could adequately handle or reject non-integer values.

Test Scenario 11:
  Test the function with an array of integers including zero. Check whether function sorting array properly when there are zeros in the array.
*/
package CountingSort

import (
	"fmt"
	"reflect"
	"testing"
)

// TestCountingSort_197b864c60 executes multiple test cases against the function countingSort()
func TestCountingSort_197b864c60(t *testing.T) {
	testCases := []struct {
		description string
		input       []int
		expected    []int
		expectedErr error
	}{
		{
			description: "array of integers in ascending order",
			input:       []int{1, 2, 3, 4, 5},
			expected:    []int{1, 2, 3, 4, 5},
		},
		{
			description: "array of integers in descending order",
			input:       []int{5, 4, 3, 2, 1},
			expected:    []int{1, 2, 3, 4, 5},
		},
		{
			description: "array containing both positive and negative integers",
			input:       []int{-3, 1, -2, 4, -1},
			expected:    []int{-3, -2, -1, 1, 4},
			expectedErr: ErrNegativeNumber,
		},
		{
			description: "array containing same integer values",
			input:       []int{2, 2, 2, 2, 2},
			expected:    []int{2, 2, 2, 2, 2},
		},
		{
			description: "array of integers contains very large and very small integers",
			input:       []int{1000000, -1000000, 0, 100, -100},
			expected:    []int{-1000000, -100, 0, 100, 1000000},
			expectedErr: ErrNegativeNumber,
		},
		{
			description: "array containing only one value",
			input:       []int{100},
			expected:    []int{100},
		},
		{
			description: "empty array",
			input:       []int{},
			expected:    []int{},
		},
		{
			description: "array of integers including zero",
			input:       []int{10, 0, -10, 20, -20},
			expected:    []int{-20, -10, 0, 10, 20},
			expectedErr: ErrNegativeNumber,
		},
	}

	for _, testCase := range testCases {
		t.Run(testCase.description, func(t *testing.T) {
			output, err := countingSort(testCase.input)
			if err != testCase.expectedErr {
				t.Errorf("Expected error %v, but got %v", testCase.expectedErr, err)
			}
			if !reflect.DeepEqual(output, testCase.expected) {
				t.Errorf("Expected %v, but got %v", testCase.expected, output)
			}
		})
	}
}

// TODO - Implement the ErrNegativeNumber error type
var ErrNegativeNumber error = fmt.Errorf("array contains negative number")
